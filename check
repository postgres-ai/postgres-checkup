#!/bin/bash
#
# 2018 © Victor Yagofarov victor@postgres.ai
# 2018 © Postgres.ai
#
# Perform a PostgreSQL instance(s) health checks
# Usage: $0 --help
#

# GLOBALS (user-assigned variables)

# GLOBALS (autoload, do not change)
: ${DEBUG:=FALSE}
SCRIPTNAME=$(basename $0)
SCRIPT_DIR=$(dirname $0)
SAFE_IFS="$IFS"
FIRST_ARG="$1"

#######################################
# Print an message to STDOUT
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   (text) STDOUT
#######################################
function msg() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')] $@"
}

#######################################
# Print a debug-level message to STDOUT
# Globals:
#   DEBUG
# Arguments:
#   (text) Message
# Returns:
#   None
#######################################
function dbg() {
  if [[ $DEBUG == "true" ]] ; then
    msg "DEBUG: ${FUNCNAME[1]}: $@"
  fi
}

#######################################
# Print an error/warning/notice message to STDERR
#   Please use 'exit' with code after usage
#   of this function (if needed)
# Globals:
#   None
# Arguments:
#   (text) Error message
# Returns:
#   (text) STDERR
#######################################
function err() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')] ERROR: $@" >&2
}

#######################################
# Error trapping function, prints line number
# Globals:
#   SCRIPTNAME, BASH_LINENO[0]
# Arguments:
#   (text) Message
# Returns:
#   (lines with text) STDOUT
#######################################
error_handler() {
  err "^^^ ERROR at [file: '${SCRIPTNAME}', line: '${BASH_LINENO[0]}']" >&2
  #TODO(vyagofarov): save step here
  echo >&2
}

#######################################
# Read non-comment and non-empty lines from cli.conf
# Globals:
#   SCRIPT_DIR
# Arguments:
#   None
# Returns:
#   (lines with text) STDOUT
#######################################
load_cli_res() {
  local setting
  if [[ ! -f "${SCRIPT_DIR}/resources/cli.conf" ]]; then
    err "Can't load '${SCRIPT_DIR}/resources/cli.conf'"
    exit 2
  fi
  while read -r setting; do
    # skip comments
    local re='^(#|$|[:blank:])'
    [[ "$setting" =~ $re ]] && continue
    echo "${setting}'"
  done <${SCRIPT_DIR}/resources/cli.conf
}

#######################################
# Fill structures with possible CLI arguments from file
# Globals:
#   CLI_ARGS_POSSIBLE, SECTION[], SHORT_NAME[],
#   FULL_NAME[], ARG_TYPE[], MANDATARY[], DESCRIPTION[]
# Arguments:
#   None
# Returns:
#   None
#######################################
read_possible_args() {
  local iter_num=0
  local section short_name full_name arg_type mandatary description

  if [[ ! -f "${SCRIPT_DIR}/resources/cli.conf" ]]; then
    err "Can't load '${SCRIPT_DIR}/resources/cli.conf'"
    exit 2
  fi

  while IFS="|" read -r section short_name full_name internal_name arg_type mandatary description; do
    # cut last garbage symbol
    # TODO(vyagofarov): understand this 'cutting' behavior
    description=${description%?}

    SECTION[$iter_num]="$section"
    SHORT_NAME[$iter_num]="$short_name"
    FULL_NAME[$iter_num]="$full_name"
    INTERNAL_NAME[$iter_num]="$internal_name"
    ARG_TYPE[$iter_num]="$arg_type"
    MANDATARY[$iter_num]="$mandatary"
    DESCRIPTION[$iter_num]="$description"

    dbg "iteration number: $iter_num"
    dbg "1: section '${SECTION[$iter_num]}'"
    dbg "2: short_name '${SHORT_NAME[$iter_num]}'"
    dbg "3: full_name '${FULL_NAME[$iter_num]}'"
    dbg "4: internal_name '${INTERNAL_NAME[$iter_num]}'"
    dbg "5: arg_type '${ARG_TYPE[$iter_num]}'"
    dbg "6: mandatary '${MANDATARY[$iter_num]}'"
    dbg "7: description '${DESCRIPTION[$iter_num]}'"

    iter_num=$(( iter_num + 1 ))
  done < <(load_cli_res)
  
  # $CLI_ARGS_POSSIBLE is a global index 
  # for all CLI input values and their properties,
  # starting from zero (convenient for arrays)
  CLI_ARGS_POSSIBLE=$(( iter_num - 1 ))

  dbg "possible args are readed"
}

#######################################
# Parse CLI arguments and save as an indexed array
# Globals:
#   $1, CLI_ARGS_POSSIBLE, SHORT_NAME[], FULL_NAME[], ARG_VALUE[],
#   CLI_ARGS_CNT, ARG_IS_GIVEN[]
# Arguments:
#   $@
# Returns:
#   None
#######################################
process_cli_args() {
  local cli_arg_cur_value i
  local re='^-+'
  local while_loops_cnt=0
  local second
  dbg "Valid CLI args possible count: ${CLI_ARGS_POSSIBLE}+1"
  CLI_ARGS_CNT=0
  while [[ ! -z "${1+x}" ]]; do
    # avoid infinite loop if argument is unknown
    while_loops_cnt=$(( while_loops_cnt + 1 ))
    [[ $while_loops_cnt -gt $(( CLI_ARGS_POSSIBLE * 2 )) ]] && break

    for i in $(seq 0 ${CLI_ARGS_POSSIBLE}); do
      if [[ ! -z "${1+x}" ]]; then
        case $1 in
          "-${SHORT_NAME[$i]}" | "--${FULL_NAME[$i]}" )
            if [[ ! -z "${2+x}" ]]; then
              second=$2
            else
              second=None
              err "empty value for variable '--${FULL_NAME[$i]}'"
              exit 1
            fi
            [[ -z "$second" ]] && exit 1
            dbg "argname: '$1', argvalue '${second}' "
            if [[ "$second" =~ $re ]]; then
              err "empty value in '--${FULL_NAME[$i]}'"
              exit 1
            fi
            # save argument value as an indexed array
            ARG_VALUE[$i]="$second"
            ARG_IS_GIVEN[$i]="true"
            CLI_ARGS_CNT=$(( CLI_ARGS_CNT + 1 ))
            shift 2
        esac
      fi
    done
  done
  dbg "given arguments count: '$CLI_ARGS_CNT'"
}

#######################################
# Validate single argument type
# Globals:
#   None
# Arguments:
#   $1, $2, $3
# Returns:
#   None
#######################################
validate_arg_type() {
  local name="$1"
  local type="$2"
  local value="$3"
  local re

  if [ -z "$name" -o -z "$type" -o -z "$value" ]; then
     err "name: '$name', type: '$type', value: '$value'"
  fi

  if [[ "$type" = "number" ]]; then
    re='^[0-9]+$'
    if ! [[ $value =~ $re ]] ; then
       err "'$name' = '$value' => is not a '$type' (${re})"
       exit 1
    fi
  elif [ $type = "word" ]; then
    re='^[a-zA-Z]+$'
    if ! [[ $value =~ $re ]]; then
       err "'$name' = '$value' => is not a '$type' (${re})"
       exit 1
    fi
  elif [ $type = "alnum" ]; then
    re='^[a-zA-Z0-9\.]+$'
    if ! [[ $value =~ $re ]]; then
       err "'$name' = '$value' => is not a '$type' (${re})"
       exit 1
    fi
  elif [[ $type = "uri" ]]; then
    re='^[a-zA-Z\;\:\\\/]+.*'
    if ! [[ $value =~ $re ]]; then
       err "'$name' = '$value' => is not a '$type' (${re})"
       exit 1
    fi
  elif [[ $type = "text" ]]; then
    re='^[a-zA-Z\;]+.*'
    if ! [[ $value =~ $re ]]; then
       err "'$name' = '$value' => is not a '$type' (${re})"
       exit 1
    fi
  else
    err "'$name' = '$value' => unknown argument type, validation error"
    exit 1
  fi
}

#######################################
# Validate arguments and and save input variables
# Globals:
#   CLI_ARGS_POSSIBLE, SECTION[], SHORT_NAME[],
#   FULL_NAME[], ARG_TYPE[], MANDATARY[], DESCRIPTION[],
#   ARG_VALUE[], ARG_IS_GIVEN[], INTERNAL_*, CLI_ARGS_CNT,
#   MANDATORY[], PSQL_CONN_OPTIONS
# Arguments:
#   None
# Returns:
#   None
#######################################
validate_args() {
  local i
  local x=0
  local re="-+(help|usage|\?)"
  local need_fail_exit="false"

  if [[ "$FIRST_ARG" =~ $re ]]; then
     usage "Help" "0"
     exit 0
  fi

  if [[ "${CLI_ARGS_CNT}" -lt 1 ]]; then
    usage "given less then 1 argument" "1"
  fi
  
  DBURI="None"

  for i in $(seq 0 ${CLI_ARGS_POSSIBLE}); do
    if [[ ! -z "${ARG_IS_GIVEN[$i]+x}" ]]; then
      # generate dynamic variables like "$HOST" and export them
      # to make visible from healthcheck scripts
      eval "${INTERNAL_NAME[$i]}"="${ARG_VALUE[$i]}"
      validate_arg_type "${FULL_NAME[$i]}" "${ARG_TYPE[$i]}" "${ARG_VALUE[$i]}"
    else
      declare -x "${INTERNAL_NAME[$i]}=None"
    fi
  done

  # override --host, --port and --dbname by --db-uri
  # and set connection options for a psql command
  if [[ "${DBURI}" = "None" ]]; then
    PSQL_CONN_OPTIONS="--host=${HOST} --port=${PORT} --dbname=${DBNAME}"
  else
    PSQL_CONN_OPTIONS="'$DBURI'"
    # threat arguments as given if we've got --db-uri (hack)
    for i in $(seq 0 ${CLI_ARGS_POSSIBLE}); do
      [[ "${INTERNAL_NAME[$i]}" = "HOST" ]] && ARG_IS_GIVEN[$i]="true"
      [[ "${INTERNAL_NAME[$i]}" = "PORT" ]] && ARG_IS_GIVEN[$i]="true"
      [[ "${INTERNAL_NAME[$i]}" = "DBNAME" ]] && ARG_IS_GIVEN[$i]="true"
    done
  fi

  export PSQL_CONN_OPTIONS="$PSQL_CONN_OPTIONS"

  dbg ""
  dbg "PSQL_CONN_OPTIONS: $PSQL_CONN_OPTIONS"
  dbg ""

  # error if mandatory options are not set
  local buf=""
  for i in $(seq 0 ${CLI_ARGS_POSSIBLE}); do
    if [[ "${MANDATARY[$i]}" == "mandatory" ]] && [[ -z "${ARG_IS_GIVEN[$i]+x}" ]] ; then
      # please do not change align for 'buf' variable text
      buf="$buf
  mandatory option '--${FULL_NAME[$i]}' is not set"
      need_fail_exit="true"
    fi
  done
  if [[ "$need_fail_exit" = "true" ]]; then
    usage "$buf" "1"
  fi
}

#######################################
# Generate usage/help
# Globals:
#   CLI_ARGS_POSSIBLE, FULL_NAME[], SECTION[]
#   SCRIPTNAME, SHORT_NAME[], DESCRIPTION[]
# Arguments:
#   description exit_code code
# Returns:
#   (text) stdtout/stderror
#######################################
usage() {
  local i
  local description="$1"
  local exit_code="$2"
  local exit_code=${exit_code:=0}
  local out_descriptor
  local re="[a-zA-Z]"
  if [[ ! "$description" =~ $re ]]; then
    err "First argument of 'usage' must be a text description"
    exit 1
  fi
  # if error: print reason before 'Usage:'
  if [[ "$exit_code" -ne "0" ]]; then
    out_descriptor="2" # STDERR
    echo "ERROR:  " >&${out_descriptor}
    echo "  $description" >&${out_descriptor}
    echo >&${out_descriptor}
  else
    out_descriptor="1" # STDOUT
    # help part starts here
    echo "PgHealth is the PostgreSQL ultimate healthcheck utility." >&${out_descriptor}
    echo >&${out_descriptor}
  fi

  echo "Usage:" >&${out_descriptor}
  echo "  ${SCRIPTNAME} OPTION OPTION..." >&${out_descriptor}
  echo "  ${SCRIPTNAME} --help" >&${out_descriptor}
  echo >&${out_descriptor}

  # calc max size of FULL_NAME[] for text alignment
  local max_name_len=0
  for i in $(seq 0 ${CLI_ARGS_POSSIBLE}); do 
    bytlen=${#FULL_NAME[$i]}
    if [[ "$bytlen" -ge "$max_name_len" ]]; then
      max_name_len=$bytlen
    fi 
  done

  local space
  local prev_section="Misc"
  for i in $(seq 0 ${CLI_ARGS_POSSIBLE}); do
    if [[ "${SECTION[$i]}" != "$prev_section" ]] || [[ -z ${SECTION[0]} ]] ; then
      echo  "${SECTION[$i]}:" >&${out_descriptor}
    fi
    [[ "${SHORT_NAME[$i]}" = "None" ]] && SHORT_NAME[$i]=" "
    if [[ "${SHORT_NAME[$i]}" = " " ]]; then
      echo -n "     "${SHORT_NAME[$i]} >&${out_descriptor}
    else
      echo -n "  -"${SHORT_NAME[$i]}"," >&${out_descriptor}
    fi
    curr_byte_len=${#FULL_NAME[$i]}
    # print space padding
    for f in $(seq 0 $(( max_name_len - curr_byte_len + 2 )) ); do
      echo -n " "  >&${out_descriptor}
    done
    echo -n " --"${FULL_NAME[$i]} >&${out_descriptor} 
    echo    "   "${DESCRIPTION[$i]} >&${out_descriptor}
    # print options about this usage/help and additional info in the last iteration
    curr_byte_len="help"
    curr_byte_len=${#curr_byte_len}
    if [[ "$i" -eq "$CLI_ARGS_POSSIBLE" ]]; then
      echo -n "  -?," >&${out_descriptor}
      for f in $(seq 0 $(( max_name_len - curr_byte_len + 2 )) ); do
        echo -n " "  >&${out_descriptor}
      done
      echo -n " --help" >&${out_descriptor} 
      echo    "   this help" >&${out_descriptor}
      # additional info
      echo >&${out_descriptor}
      echo "To add more options please edit file 'resources/cli.conf'."
      echo >&${out_descriptor}
      echo "Report bugs to https://github.com/postgres-ai/postgres-health-check/ ." >&${out_descriptor}
    fi
    prev_section=${SECTION[$i]}
  done
 
  exit $exit_code
}

#######################################
# Perform checks
# All checks must return valid json into stdout
# Globals:
#   CURRENT_CHECK, SCRIPT_DIR, CHECK_ID
#   and all exported internal globals
# Arguments:
#   None
# Returns:
#   (text) stdtout/stderror
#######################################
run_checks() {
  local output
  for CURRENT_CHECK in "${SCRIPT_DIR}"/resources/checks/*_*.sh; do
    [[ -e "$CURRENT_CHECK" ]] || continue
    msg "========== Perform check: =========="
    msg "$CURRENT_CHECK"
    msg ""
    output=$(source "$CURRENT_CHECK" || true)
    msg "========== End of check: ==========="
    # extract checkId from check script path
    local check_path_name="$CURRENT_CHECK"
    check_path_name=${check_path_name%_*.sh}
    check_path_name=${check_path_name##*/}
    export CHECK_ID="$check_path_name"
    msg "$CHECK_ID"
    mkdir -p "${SCRIPT_DIR}/artifacts/${PROJECT}"
    generate_report_json "$output" "$CHECK_ID"
  done
}

#######################################
# Generate json report
# Globals:
#   CURRENT_CHECK, SCRIPT_DIR, PROJECT,
#   HOST, 
# Arguments:
#   input, check_id
# Returns:
#   (text) stdtout/stderror
#######################################
generate_report_json() {
  local input_json="$1"
  local check_id="$2"

  #TODO(vyagofarov): make uniq temp file names

  local template_fname="${SCRIPT_DIR}/resources/templates/report.json"
  # insert json object data into template
  local tmp_input_json_fname="${SCRIPT_DIR}/artifacts/${check_id}.tmp"
  touch "$tmp_input_json_fname"
  echo "$input_json" > "$tmp_input_json_fname"
  local timestamp=$(date +'%Y_%m_%dT%H_%M_%S_%z')
  mkdir -p "${SCRIPT_DIR}/artifacts/${PROJECT}/${timestamp}"
  local report_fname="${SCRIPT_DIR}/artifacts/${PROJECT}/$timestamp/${check_id}.json"

  jq --argfile Data \
    "${tmp_input_json_fname}" '.checkId = "'"${check_id}"'" | .hosts[] += "'"${HOST}"'" | .checkData += {'"$HOST"': $Data }' "$template_fname" \
    > "$report_fname"
  msg "Artifacts saved at: '${report_fname}'"
  rm "$tmp_input_json_fname"
}

################ COMMANDS #############
psql ()
{
  command psql -X -At -q -v ON_ERROR_STOP=1 -P pager=off "$@"
}

main() {
  set -ueo pipefail
  trap error_handler ERR
  unset LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES LC_TIME LC_NUMERIC
  export LC_ALL=C
  read_possible_args && ARGS_ARE_READED="true"
  process_cli_args "$@"
  validate_args
  run_checks
}

main "$@"

# last line of the file
