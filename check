#!/bin/bash
#
# 2018 © Victor Yagofarov victor@postgres.ai
# 2018 © Postgres.ai
#
# Perform a PostgreSQL instance(s) health checks
# Usage: $0 --help
#

# GLOBALS (user-assigned variables)
CMD_TIMEOUT="10" # timeout for command (ssh, psql, etc.)
                 # TODO(vyagofarov): think about timing 
                 # out commands in macOS

# GLOBALS (autoload, do not change)
: ${DEBUG:=FALSE}
SCRIPTNAME=$(basename $0)
SCRIPT_DIR=$(dirname $0)
SAFE_IFS="$IFS"
FIRST_ARG="$1"
OPTIONS_ERROR_EXIT=false

#######################################
# Print an message to STDOUT
# Globals:
#   None
# Arguments:
#   None
# Returns:
#   (text) STDOUT
#######################################
function msg() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')] $@"
}

#######################################
# Print a debug-level message to STDOUT
# Globals:
#   DEBUG
# Arguments:
#   (text) Message
# Returns:
#   None
#######################################
function dbg() {
  if [[ $DEBUG == "true" ]] ; then
    msg "DEBUG: ${FUNCNAME[1]}: $@"
  fi
}

#######################################
# Print an error/warning/notice message to STDERR
#   Please use 'exit' with code after usage
#   of this function (if needed)
# Globals:
#   None
# Arguments:
#   (text) Error message
# Returns:
#   (text) STDERR
#######################################
function err() {
  echo "[$(date +'%Y-%m-%dT%H:%M:%S%z')] ERROR: ${FUNCNAME[1]}: $@" >&2
}

#######################################
# Error trapping function, prints line number
# Globals:
#   SCRIPTNAME, BASH_LINENO[0]
# Arguments:
#   (text) Message
# Returns:
#   (lines with text) STDOUT
#######################################
error_handler() {
  err "^^^ ERROR at [file: '${SCRIPTNAME}', line: '${BASH_LINENO[0]}']" >&2
  echo >&2
}

#######################################
# Cleanup function: close ssh sockets, etc.
# Globals:
#   HOST
# Arguments:
#   None
# Returns:
#   (lines with text) STDOUT/STDERR
#######################################
cleanup_and_exit() {
  if [[ ! -z ${HOST+x} ]]; then
    dbg "closing ssh conenction to host '$HOST' (if exists)"
    ssh -O exit ${HOST} 2>/dev/null || true
  fi
}

#######################################
# Read non-comment and non-empty lines from cli.conf
# Globals:
#   SCRIPT_DIR
# Arguments:
#   None
# Returns:
#   (lines with text) STDOUT
#######################################
load_cli_res() {
  local setting
  if [[ ! -f "${SCRIPT_DIR}/resources/cli.conf" ]]; then
    err "Can't load '${SCRIPT_DIR}/resources/cli.conf'"
    exit 2
  fi
  while read -r setting; do
    # skip comments
    local re='^(#|$|[:blank:])'
    [[ "$setting" =~ $re ]] && continue
    echo "${setting}'"
  done <"${SCRIPT_DIR}"/resources/cli.conf
}

#######################################
# Fill structures with possible CLI arguments from file
# Globals:
#   CLI_ARGS_POSSIBLE, SECTION[], SHORT_NAME[],
#   FULL_NAME[], ARG_TYPE[], MANDATARY[], DESCRIPTION[],
#   ARGS_ARE_READED
# Arguments:
#   None
# Returns:
#   None
#######################################
read_possible_args() {
  local iter_num=0
  local section short_name full_name arg_type mandatary description

  if [[ ! -f "${SCRIPT_DIR}/resources/cli.conf" ]]; then
    err "Can't load '${SCRIPT_DIR}/resources/cli.conf'"
    exit 2
  fi

  while IFS="|" read -r section short_name full_name internal_name arg_type mandatary description; do
    # cut last garbage symbol
    # TODO(vyagofarov): understand this 'cutting' behavior
    description=${description%?}

    SECTION[$iter_num]="$section"
    SHORT_NAME[$iter_num]="$short_name"
    FULL_NAME[$iter_num]="$full_name"
    INTERNAL_NAME[$iter_num]="$internal_name"
    ARG_TYPE[$iter_num]="$arg_type"
    MANDATARY[$iter_num]="$mandatary"
    DESCRIPTION[$iter_num]="$description"

    dbg "iteration number: $iter_num"
    dbg "1: section '${SECTION[$iter_num]}'"
    dbg "2: short_name '${SHORT_NAME[$iter_num]}'"
    dbg "3: full_name '${FULL_NAME[$iter_num]}'"
    dbg "4: internal_name '${INTERNAL_NAME[$iter_num]}'"
    dbg "5: arg_type '${ARG_TYPE[$iter_num]}'"
    dbg "6: mandatary '${MANDATARY[$iter_num]}'"
    dbg "7: description '${DESCRIPTION[$iter_num]}'"

    iter_num=$(( iter_num + 1 ))
  done < <(load_cli_res)
  
  # $CLI_ARGS_POSSIBLE is a global index 
  # for all CLI input values and their properties,
  # starting from zero (convenient for arrays)
  CLI_ARGS_POSSIBLE=$(( iter_num - 1 ))

  ARGS_ARE_READED="true"
  dbg "possible args are readed"
}

#######################################
# Parse CLI arguments and save as an indexed array
# Globals:
#   $1, CLI_ARGS_POSSIBLE, SHORT_NAME[], FULL_NAME[], ARG_VALUE[],
#   CLI_ARGS_CNT, ARG_IS_GIVEN[]
# Arguments:
#   $@
# Returns:
#   None
#######################################
process_cli_args() {
  local cli_arg_cur_value i
  local re='^-+'
  local while_loops_cnt=0
  local second
  dbg "Valid CLI args possible count: ${CLI_ARGS_POSSIBLE}+1"
  CLI_ARGS_CNT=0
  while [[ ! -z "${1+x}" ]]; do
    # avoid infinite loop if argument is unknown
    while_loops_cnt=$(( while_loops_cnt + 1 ))
    [[ $while_loops_cnt -gt $(( CLI_ARGS_POSSIBLE * 2 )) ]] && break

    for i in $(seq 0 ${CLI_ARGS_POSSIBLE}); do
      if [[ ! -z "${1+x}" ]]; then
        case $1 in
          "-${SHORT_NAME[$i]}" | "--${FULL_NAME[$i]}" )
            if [[ ! -z "${2+x}" ]]; then
              second="$2"
            else
              second=None
              err "empty value for variable '--${FULL_NAME[$i]}'"
              exit 1
            fi
            [[ -z "$second" ]] && exit 1
            dbg "argname: '$1', argvalue '${second}' "
            if [[ "$second" =~ $re ]]; then
              err "empty value in '--${FULL_NAME[$i]}'"
              exit 1
            fi
            # save argument value as an indexed array
            ARG_VALUE[$i]="$second"
            ARG_IS_GIVEN[$i]="true"
            CLI_ARGS_CNT=$(( CLI_ARGS_CNT + 1 ))
            shift 2
        esac
      fi
    done
  done
  dbg "given arguments count: '$CLI_ARGS_CNT'"
}

#######################################
# Validate single argument type
# Globals:
#   None
# Arguments:
#   $1, $2, $3
# Returns:
#   None
#######################################
validate_arg_type() {
  local name="$1"
  local type="$2"
  local value="$3"
  local re

  if [ -z "$name" -o -z "$type" -o -z "$value" ]; then
     err "name: '$name', type: '$type', value: '$value'"
  fi

  if [[ "$type" = "number" ]]; then
    re='^[0-9]+$'
    if ! [[ $value =~ $re ]] ; then
       err "'$name' = '$value' => is not a '$type' (${re})"
       exit 1
    fi
  elif [ $type = "word" ]; then
    re='^[a-zA-Z_-]+$'
    if ! [[ $value =~ $re ]]; then
       err "'$name' = '$value' => is not a '$type' (${re})"
       exit 1
    fi
  elif [ $type = "alnum" ]; then
    re='^[a-zA-Z0-9\.]+$'
    if ! [[ $value =~ $re ]]; then
       err "'$name' = '$value' => is not a '$type' (${re})"
       exit 1
    fi
  elif [[ $type = "uri" ]]; then
    re='^[a-zA-Z\;\:\\\/]+.*'
    if ! [[ $value =~ $re ]]; then
       err "'$name' = '$value' => is not a '$type' (${re})"
       exit 1
    fi
  elif [[ $type = "text" ]]; then
    re='^[a-zA-Z\;\s\\\/]+.*'
    if ! [[ $value =~ $re ]]; then
       err "'$name' = '$value' => is not a '$type' (${re})"
       exit 1
    fi
  else
    err "'$name' = '$value' => unknown argument type, validation error"
    exit 1
  fi
}

#######################################
# Validate arguments and and save input variables
# Globals:
#   CLI_ARGS_POSSIBLE, SECTION[], SHORT_NAME[],
#   FULL_NAME[], ARG_TYPE[], MANDATARY[], DESCRIPTION[],
#   ARG_VALUE[], ARG_IS_GIVEN[], INTERNAL_*, CLI_ARGS_CNT,
#   MANDATORY[], PSQL_CONN_OPTIONS, HOST, OPTIONS_ERROR_EXIT
# Arguments:
#   None
# Returns:
#   None
#######################################
validate_args() {
  local i
  local x=0
  local re="-+(help|usage|\?)"
  local need_fail_exit="false"

  if [[ "$FIRST_ARG" =~ $re ]]; then
     usage "Help" "0"
     exit 0
  fi

  if [[ "${CLI_ARGS_CNT}" -lt 1 ]]; then
    usage "given less then 1 mandatory argument" "1"
  fi

  for i in $(seq 0 ${CLI_ARGS_POSSIBLE}); do
    if [[ ! -z "${ARG_IS_GIVEN[$i]+x}" ]]; then
      # generate dynamic variables like "$HOST" and export them
      # to make visible from healthcheck scripts
      eval "export ${INTERNAL_NAME[$i]}"="${ARG_VALUE[$i]}"
      validate_arg_type "${FULL_NAME[$i]}" "${ARG_TYPE[$i]}" "${ARG_VALUE[$i]}"
    else
      export "${INTERNAL_NAME[$i]}=None"
    fi
  done

  # fill default (not given) psql connection related variables
  [[ "${PORT}" = "None" ]] && export PORT=5432
  [[ "${DBNAME}" = "None" ]] && export DBNAME=postgres
  [[ "${USERNAME}" = "None" ]] && export USERNAME="${USER}"

  # custom UNIX domain socket directory for PostgreSQL
  local psql_host_opt=""
  if [[ "${PGSOCKET}" != "None" ]]; then
    psql_host_opt=" --host '${PGSOCKET}' "  
  fi

  export PSQL_CONN_OPTIONS="--port=${PORT} --dbname=${DBNAME} --username=${USERNAME} ${psql_host_opt}"
  export _PSQL="psql -X -At -q -v ON_ERROR_STOP=1 -P pager=off ${PSQL_CONN_OPTIONS} \"$@\""

  dbg ""
  dbg "PSQL_CONN_OPTIONS: $PSQL_CONN_OPTIONS"
  dbg ""


  # error if mandatory options are not set (print as a stack)
  local buf=""
  for i in $(seq 0 ${CLI_ARGS_POSSIBLE}); do
    if [[ "${MANDATARY[$i]}" == "mandatory" ]] && [[ -z "${ARG_IS_GIVEN[$i]+x}" ]] ; then
      # please do not change align for 'buf' variable text
      buf="$buf
  mandatory option '--${FULL_NAME[$i]}' is not set"
      need_fail_exit=true
      OPTIONS_ERROR_EXIT=true
    fi
  done
  if [[ "$need_fail_exit" = "true" ]]; then
    usage "$buf" "1"
  fi
}

#######################################
# Generate usage/help
# Globals:
#   CLI_ARGS_POSSIBLE, FULL_NAME[], SECTION[]
#   SCRIPTNAME, SHORT_NAME[], DESCRIPTION[]
# Arguments:
#   description exit_code code
# Returns:
#   (text) stdtout/stderror
#######################################
usage() {
  local i
  local description="$1"
  local exit_code="$2"
  local exit_code=${exit_code:=0}
  local out_descriptor
  local re="[a-zA-Z]"
  if [[ ! "$description" =~ $re ]]; then
    err "First argument of 'usage' must be a text description"
    exit 1
  fi
  # if error: print reason before 'Usage:'
  if [[ "$exit_code" -ne "0" ]]; then
    out_descriptor="2" # STDERR
    echo "ERROR:  " >&${out_descriptor}
    echo "  $description" >&${out_descriptor}
    echo >&${out_descriptor}
  else
    out_descriptor="1" # STDOUT
    # help part starts here
    echo "PgHealth is the PostgreSQL ultimate healthcheck utility." >&${out_descriptor}
    echo >&${out_descriptor}
  fi

  echo "Usage:" >&${out_descriptor}
  echo "  ${SCRIPTNAME} OPTION [OPTION] ..." >&${out_descriptor}
  echo "  ${SCRIPTNAME} --help" >&${out_descriptor}
  echo >&${out_descriptor}

  # calc max size of FULL_NAME[] for text alignment
  local max_name_len=0
  for i in $(seq 0 ${CLI_ARGS_POSSIBLE}); do 
    bytlen=${#FULL_NAME[$i]}
    if [[ "$bytlen" -ge "$max_name_len" ]]; then
      max_name_len=$bytlen
    fi 
  done

  local space
  local prev_section="Misc"
  for i in $(seq 0 ${CLI_ARGS_POSSIBLE}); do
    if [[ "${SECTION[$i]}" != "$prev_section" ]] || [[ -z ${SECTION[0]} ]] ; then
      echo  "${SECTION[$i]}:" >&${out_descriptor}
    fi
    [[ "${SHORT_NAME[$i]}" = "None" ]] && SHORT_NAME[$i]=" "
    if [[ "${SHORT_NAME[$i]}" = " " ]]; then
      echo -n "     "${SHORT_NAME[$i]} >&${out_descriptor}
    else
      echo -n "  -"${SHORT_NAME[$i]}"," >&${out_descriptor}
    fi
    curr_byte_len=${#FULL_NAME[$i]}
    # print space padding
    for f in $(seq 0 $(( max_name_len - curr_byte_len + 2 )) ); do
      echo -n " "  >&${out_descriptor}
    done
    echo -n " --"${FULL_NAME[$i]} >&${out_descriptor} 
    echo    "   "${DESCRIPTION[$i]} >&${out_descriptor}
    # print options about this usage/help and additional info in the last iteration
    curr_byte_len="help"
    curr_byte_len=${#curr_byte_len}
    if [[ "$i" -eq "$CLI_ARGS_POSSIBLE" ]]; then
      echo -n "  -?," >&${out_descriptor}
      for f in $(seq 0 $(( max_name_len - curr_byte_len + 2 )) ); do
        echo -n " "  >&${out_descriptor}
      done
      echo -n " --help" >&${out_descriptor} 
      echo    "   this help" >&${out_descriptor}
      # additional info
      echo >&${out_descriptor}
      echo "Example:" >&${out_descriptor}
      echo "./${SCRIPTNAME} -h localhost -p 5432 --username ${USER} --dbname postgres --project dummy" >&${out_descriptor}
      echo >&${out_descriptor}
      echo "To add more options please edit file 'resources/cli.conf'." >&${out_descriptor}
      echo >&${out_descriptor}
      echo "Report bugs to https://github.com/postgres-ai/postgres-health-check/ ." >&${out_descriptor}
    fi
    prev_section=${SECTION[$i]}
  done
 
  exit $exit_code
}

#######################################
# Generate json report
# Globals:
#   CURRENT_CHECK, SCRIPT_DIR, PROJECT,
#   HOST, 
# Arguments:
#   input, check_id
# Returns:
#   (text) stdtout/stderror
#######################################
generate_report_json() {
  local input_json="$1"
  local check_id="$2"
  local check_name="$3"

  local epoch=null

  [[ -z ${3+x} ]] && err "function needs 3 arguments"

  # insert json object data into template
  local template_fname="${SCRIPT_DIR}/resources/templates/report.json"
  local tmp_input_json_fname=$(mktemp "${SCRIPT_DIR}"/artifacts/${check_id}_tmp_XXXXXX)
  echo "$input_json" > "$tmp_input_json_fname"
  local timestamp=$(date +'%Y_%m_%dT%H_%M_%S_%z')
  local timestamptz=$(date +'%Y-%m-%d %H:%M:%S.0%z')
  mkdir -p "${SCRIPT_DIR}/artifacts/${PROJECT}/${timestamp}"
  local report_fname="${SCRIPT_DIR}/artifacts/${PROJECT}/$timestamp/${check_id}_${check_name}.json"

  jq --argfile Results "${tmp_input_json_fname}" \
     --arg CheckId "${check_id}" \
     --arg CheckName "${check_name}" \
     --arg TimestampTz "${timestamptz}" \
     --arg Host "${HOST}" \
     --arg Project "${PROJECT}" \
    '.checkId = $CheckId | .name = $CheckName | ."timestamptz" = $TimestampTz | ."project" = $Project | .results = { ($Host): $Results }' \
    "$template_fname" \
    > "$report_fname"
  msg "Artifacts saved at: '${report_fname}'"
  rm "$tmp_input_json_fname"
}

#######################################
# Perform checks
# All checks must return valid json into stdout
# Globals:
#   CURRENT_CHECK, SCRIPT_DIR, HOST
#   and all exported internal globals
# Arguments:
#   None
# Returns:
#   (text) stdtout/stderror
#######################################
run_checks() {
  local output
  for CURRENT_CHECK in "${SCRIPT_DIR}"/resources/checks/*_*.sh; do
    [[ -e "$CURRENT_CHECK" ]] || continue
    msg ""
    msg "========== Perform check: =========="
    msg "$CURRENT_CHECK"

    local check_is_failed=false

    output=$(set -euo pipefail ; source "$CURRENT_CHECK") || check_is_failed="true"

    dbg "is check failed?: $check_is_failed"
    msg "========== End of check ==========="
    # extract checkId from check script path
    local check_path_name="$CURRENT_CHECK"
    local check_id_tmp_a=${check_path_name%_*.sh}
    local check_id="${check_id_tmp_a##*/}"

    local check_name_a="${check_path_name##*/}"
    local check_name_b="${check_name_a##*_}"
    local check_name="${check_name_b%.sh}"

    if [[ "$check_is_failed" == "true" ]]; then
      msg "WARNING: check '${check_id}' failed with error ^^^"
      continue
    else
      msg "check '$check_id' is finished"
    fi
    mkdir -p "${SCRIPT_DIR}/artifacts/${PROJECT}"
    generate_report_json "$output" "$check_id" "$check_name"
  done
}

######### COMMANDS WRAPPERS ###########
ssh() {
  local ssh_timeout_options="-o ConnectTimeout=10 -o ServerAliveInterval=6 -o ServerAliveCountMax=5"
  local ssh_options="-o StrictHostKeyChecking=no -o Compression=no -o BatchMode=yes ${ssh_timeout_options}"

  local ssh_master_socket='/tmp/ssh_pg_check_%h_%p_%r'
  local ssh_master_options="-o ControlMaster=auto -o ControlPersist=yes"
  local ssh_persist=true

  if [[ "$ssh_persist" = "true" ]]; then
      ssh_options="$ssh_options -S $ssh_master_socket $ssh_master_options"
  fi

  command ssh $ssh_options "$@"
}

#######################################
main() {
  set -ueo pipefail
  trap error_handler ERR
  trap cleanup_and_exit 1 2 13 15 EXIT
  unset LANG LANGUAGE LC_ALL LC_CTYPE LC_COLLATE LC_MESSAGES LC_TIME LC_NUMERIC
  export LC_ALL=C
  read_possible_args
  process_cli_args "$@"
  validate_args
  run_checks
  exit 0
}

main "$@"

# last line of the file